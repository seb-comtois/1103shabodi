from tkinter import Toplevel, Label, Button
import socket
import struct
import pickle
import cv2
import pyaudio
import threading

# Configure the server address and port
SERVER_ADDRESS = '172.20.10.3'  # Replace with the actual IP address of the secondary computer
SERVER_PORT = 9999

def open_dashboard(root, refresh_main_window):
    print("Opening Dashboard Window")
    dashboard_win = Toplevel(root)
    dashboard_win.title("Dashboard")
    dashboard_win.geometry("400x400")
    dashboard_win.configure(bg="#1A1A1A")

    Label(dashboard_win, text="Dashboard", font=("Helvetica", 16, "bold"), fg="white", bg="#1A1A1A").pack(pady=20)

    # Button to connect to your friend's laptop
    Button(dashboard_win, text="Connect to Friend's Laptop", bg="grey", fg="black", width=25, height=2,
           command=start_stream_thread).pack(pady=10)

    # Back button to return to the main screen
    Button(dashboard_win, text="Back", command=lambda: [dashboard_win.destroy(), refresh_main_window(root)],
           bg="grey", fg="black").place(x=10, y=360)

    dashboard_win.protocol("WM_DELETE_WINDOW", lambda: [dashboard_win.destroy(), refresh_main_window(root)])

def start_stream_thread():
    # Start video and audio streaming in a separate thread
    threading.Thread(target=start_video_audio_stream, daemon=True).start()

def start_video_audio_stream():
    # Setup socket connection to receive video (and optional audio) from the secondary computer
    client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    client_socket.connect((SERVER_ADDRESS, SERVER_PORT))

    # Initialize PyAudio for optional audio playback
    p = pyaudio.PyAudio()
    audio_stream = p.open(format=pyaudio.paInt16, channels=1, rate=44100, output=True, frames_per_buffer=1024)

    data = b""
    payload_size = struct.calcsize("L")  # Define the size of the message length pack

    try:
        while True:
            # Ensure we have enough data to unpack the message size
            while len(data) < payload_size:
                packet = client_socket.recv(4096)  # Receive data in chunks
                if not packet:
                    return  # Connection closed by the secondary computer
                data += packet

            # Unpack and retrieve the frame size
            packed_msg_size = data[:payload_size]
            data = data[payload_size:]
            msg_size = struct.unpack("L", packed_msg_size)[0]

            # Ensure we have the entire frame data based on msg_size
            while len(data) < msg_size:
                packet = client_socket.recv(4096)
                if not packet:
                    return  # Connection closed by the secondary computer
                data += packet

            # Extract frame and display
            frame_data = data[:msg_size]
            data = data[msg_size:]
            frame = pickle.loads(frame_data)
            cv2.imshow("Smart Glasses Video", frame)

            if cv2.waitKey(1) == ord('q'):
                break

            # Optional audio handling
            # Uncomment if the secondary computer is sending audio
            # audio_message_size = struct.unpack("L", client_socket.recv(struct.calcsize("L")))[0]
            # audio_data = b""
            # while len(audio_data) < audio_message_size:
            #     audio_data += client_socket.recv(4096)
            # audio_stream.write(audio_data)

    finally:
        client_socket.close()
        audio_stream.stop_stream()
        audio_stream.close()
        p.terminate()
        cv2.destroyAllWindows()
